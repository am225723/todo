'use client';

import { useState, useEffect } from 'react';
import { Bell, BellOff } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';

function urlBase64ToUint8Array(base64String: string) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
        .replace(/-/g, '+')
        .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);

    for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

export function PushNotificationManager() {
    const [isSubscribed, setIsSubscribed] = useState(false);
    const [subscription, setSubscription] = useState<PushSubscription | null>(null);
    const [isSupported, setIsSupported] = useState(false);
    const { toast } = useToast();

    useEffect(() => {
        if ('serviceWorker' in navigator && 'PushManager' in window) {
            setIsSupported(true);
            registerServiceWorker();
        }
    }, []);

    async function registerServiceWorker() {
        try {
            // Register custom service worker if not already registered or if we want to ensure it handles push
            // next-pwa registers sw.js.
            // If we want to use custom-sw.js alongside or instead, it gets tricky.
            // The cleanest way with next-pwa without changing config is to try to rely on "worker" directory or importScripts.
            // However, since we can't easily change sw.js generated by next-pwa, we might need to rely on the user adding 'importScripts' to next.config.js workbox opts.
            // OR we can just register our custom one for the scope.

            // Let's try to register /custom-sw.js. If /sw.js is already controlling, this might replace it or sit alongside if scopes differ.
            // next-pwa registers scope '/'.

            // For this implementation, I will just ensure we wait for *any* service worker.
            // The user must manually configure next-pwa to include push logic, OR
            // I will try to register `custom-sw.js` here.

            // Warning: registering a second SW at root scope might cause issues.
            // Best approach: instruct user to add `importScripts: ['/custom-sw.js']` in next.config.js workbox options.
            // But I can't easily edit next.config.js safely without potentially breaking existing config logic if it's complex.
            // I'll check next.config.js again.

            const registration = await navigator.serviceWorker.ready;
            const sub = await registration.pushManager.getSubscription();
            if (sub) {
                setSubscription(sub);
                setIsSubscribed(true);
            }
        } catch (error) {
            console.error('Service Worker Error', error);
        }
    }

    async function subscribeToPush() {
        try {
            const registration = await navigator.serviceWorker.ready;
            const vapidPublicKey = process.env.NEXT_PUBLIC_VAPID_PUBLIC_KEY;

            if (!vapidPublicKey) {
                toast({
                    title: "Configuration Error",
                    description: "VAPID Public Key is missing.",
                    variant: "destructive"
                });
                return;
            }

            const sub = await registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: urlBase64ToUint8Array(vapidPublicKey)
            });

            setSubscription(sub);
            setIsSubscribed(true);

            // Send to backend
            await fetch('/api/notifications/subscribe', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ subscription: sub }),
            });

            toast({
                title: "Notifications Enabled",
                description: "You will now receive push notifications.",
            });
        } catch (error) {
            console.error('Subscription failed', error);
            toast({
                title: "Subscription Failed",
                description: "Could not subscribe to notifications.",
                variant: "destructive"
            });
        }
    }

    async function unsubscribeFromPush() {
         try {
            if (subscription) {
                await subscription.unsubscribe();
                // Optionally call backend to remove
            }
            setSubscription(null);
            setIsSubscribed(false);
             toast({
                 title: "Notifications Disabled",
                 description: "You will no longer receive push notifications.",
             });
        } catch (error) {
             console.error('Unsubscribe failed', error);
        }
    }

    if (!isSupported) {
        return null; // Or show a message
    }

    return (
        <div className="flex items-center space-x-2">
            {isSubscribed ? (
                <Button variant="outline" size="sm" onClick={unsubscribeFromPush}>
                    <BellOff className="h-4 w-4 mr-2" />
                    Disable Notifications
                </Button>
            ) : (
                <Button variant="outline" size="sm" onClick={subscribeToPush}>
                    <Bell className="h-4 w-4 mr-2" />
                    Enable Notifications
                </Button>
            )}
        </div>
    );
}
